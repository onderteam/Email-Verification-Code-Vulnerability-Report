# Exploiting Reused Email Verification Codes

Email verification processes are critical for ensuring the authenticity and integrity of user accounts in web applications. However, improper handling of verification codes can lead to vulnerabilities that allow attackers to bypass these mechanisms. During a bug bounty program, I identified a security flaw that enables users to exploit old verification codes, effectively bypassing email verification when reverting to a previously registered email address.

---

## Details of the Exploit

The vulnerability lies in the system's failure to invalidate previously used email verification codes, coupled with an absence of one-time-use enforcement. This allows users to reuse old verification codes to confirm an email change, bypassing proper verification steps.

### Key Observations

1. **Initial Registration and Verification**:

   - A user registers with an email (e.g., `user@example.com`) and receives a verification code.
   - The verification code is used successfully, and the email is confirmed.

2. **Email Change**:

   - The user updates their email to another address (e.g., `newuser@example.com`) and verifies the new address with a fresh code.

3. **Reverting to the Old Email**:

   - The user attempts to switch back to the original email (`user@example.com`).
   - The system sends a new verification code to the original email address.

4. **Reusing the Old Code**:
   - Instead of using the new code, the user enters the old verification code from the initial registration.
   - The system erroneously accepts the old code, confirming the email without requiring validation using the newly generated code.

---

## Steps to Reproduce the Vulnerability

1. **Step 1: Initial Registration**

   - Register a new account using an email address (e.g., `test@example.com`).
   - Use the verification code sent to the email to confirm the account.

2. **Step 2: Change the Email**

   - Update the account email to a different address (e.g., `test2@example.com`).
   - Verify the new email using the new code sent by the system.

3. **Step 3: Revert to the Old Email**

   - Attempt to change the email back to the original (`test@example.com`).
   - The system sends a new verification code to the old email address.

4. **Step 4: Reuse the Old Code**

   - Retrieve the old verification code from the initial registration attempt.
   - Submit the old code instead of the new one.

5. **Outcome**
   - The system accepts the old code and confirms the email address without requiring validation using the newly generated code.

---

## Root Cause Analysis

The vulnerability stems from the following issues in the verification system:

1. **Lack of One-Time-Use Enforcement**:

   - Verification codes are not flagged as one-time-use, allowing them to remain valid even after successful usage.

2. **Failure to Invalidate Old Codes**:

   - When a new verification code is generated, the system does not automatically invalidate previously issued codes for the same email address.

3. **Absence of Expiration Policies**:
   - Verification codes remain valid indefinitely, as the system does not enforce expiration times or timestamps.

---

## Impact of the Vulnerability

The ability to reuse old verification codes has significant implications:

1. **Email Verification Bypass**:

   - Attackers can bypass proper email verification steps, compromising the integrity of the verification process.

2. **Account Hijacking**:

   - If an attacker gains access to an old verification code, they could potentially use it to take over user accounts.

3. **Loss of User Trust**:
   - Exploiting this vulnerability could lead to a loss of trust in the applicationâ€™s security measures.

---

## Suggested Fixes

1. **Enforce One-Time-Use for Verification Codes**:

   - Flag verification codes as one-time-use and mark them as invalid immediately after successful usage.

2. **Invalidate Previous Codes on New Generation**:

   - When generating a new verification code for an email, automatically invalidate all previously issued codes for the same email.

   **Example Implementation in Pseudocode**:

   ```javascript
   function generateVerificationCode(email) {
     invalidateOldCodes(email);
     const newCode = createNewCode();
     storeCode(email, newCode);
     return newCode;
   }
   ```

3. **Set Expiration Times for Codes**:

   - Implement an expiration policy for verification codes, ensuring they are invalidated after a predefined time (e.g., 15 minutes).

   **Example Implementation in Pseudocode**:

   ```javascript
   function isCodeValid(code, email) {
     const storedCode = getCodeForEmail(email);
     if (storedCode && storedCode.timestamp + EXPIRY_TIME > Date.now()) {
       return storedCode === code;
     }
     return false;
   }
   ```

4. **Implement Cryptographic Integrity**:

   - Use cryptographic methods such as HMAC or JWT to generate and validate verification codes, ensuring they cannot be tampered with.

5. **Monitor and Log Suspicious Activity**:
   - Log activities such as multiple uses of the same verification code or code usage outside normal timeframes, and implement anomaly detection to flag suspicious patterns.

---

## General Recommendations

- **Strict Expiration Policies**:  
  Enforce expiration times for all verification codes and tokens on both the client and server sides.

- **Robust Validation Mechanisms**:  
  Ensure all codes are cryptographically signed and validated against a secure server-side database.

- **User Notifications**:  
  Notify users whenever verification codes are used or regenerated to ensure transparency and enable users to detect unauthorized attempts.

---

## Timeline and Resolution

- **Discovery Date:** November 01, 2024
- **Report Submission:** November 10, 2024
- **Triaging Completed:** November 16, 2024
- **Fix Deployed:** November 26, 2024
- **Acknowledgment:** Received a thank-you note and private recognition for the discovery.

---

This vulnerability underscores the importance of robust email verification mechanisms. By ensuring verification codes are single-use, have strict expiration times, and are cryptographically secure, applications can protect users and maintain trust in their systems. Proactive measures such as monitoring and logging suspicious activities further enhance the resilience of verification processes.
